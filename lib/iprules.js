"use strict"
var fs     = require("fs"),
    crypto = require("crypto"),
    JsonDB = require("node-json-db"),
    exec   = require("child_process").exec;

    db = new JsonDB("rules", true, false);

/**
 * Basic Interface to the iptables-restore command
 */
var IptablesRestore = {
  /**
   * Loads the argument text into iptables using
   * the iptables-restore command.  Must be
   * syntactically correct
   *
   * @param text {string} text formatted into an iptables-restore file
   * @callback err
   */
  load: function(text, callback) {
    // test the data to make sure it's good
    this.test(this.build(text), function(err) {
      if ( err ) callback(err);
      
      // test passed so write the file to /etc
      // TODO: save mode of 660
      var fn = "/etc/iptables.rules";
      fs.writeFile(fn, text, function(err) {
        if ( err ) callback(err);

        // the file was written, so load it in for realz
        exec("/sbin/iptables-restore < "+fn, function(err, stdout, stderr) {
          if ( err ) callback(err);
          callback();
        });
      });
    });
  },

  /**
   * Does a test run using the iptables-restore command
   * to test the given text 
   *
   * @param text {string} text formatted into an iptables-restore file
   * @callback err
   */
  test: function(text, callback) {
    // TODO: save mode of 660
    var fn = "/tmp/iptables.rules";
    fs.writeFile(fn, this.build(text), function(err) {
      if ( err ) callback(err);

      // the file was written so test it
      exec("/sbin/iptables-restore --test < "+fn, function(err, stdout, stderr) {
        fs.unlink(fn);
        if ( err ) callback(err);
        callback();
      });
    });
  },

  build: function(text) {
    var lines = [
      "# Generated by ipgroups "+(new Date().toLocaleString()),
      "*filter"
    ];
    lines.push(text);
    lines.push("#end");
    return lines.join("\n");
  }
};

/**
 * A parser that can translate iptables rule arguments
 * into javascript objects and vice-versa.
 */
var RuleParser = {

  /**
   * Parses the given iptables rule arguments into
   * a JS object
   *
   * @param rule {string} the iptables rule args
   * @return {object} the args split into keys of a JS hash
   */
  parse: function(rule) {
    var fm = this.firstMatch;
    return {
      chain:    fm(/-A ([A-Z]+)/      , line),
      protocol: fm(/-p (\w+)/         , line),
      dport:    fm(/--dport (\d+)/    , line),
      sport:    fm(/--sport (\d+)/    , line),
      target:   fm(/-j (\w+)/         , line),
      src:      fm(/--src ([\.0-9]+)/ , line),
      dst:      fm(/--dst ([\.0-9]+)/ , line),
      in:       fm(/-o ([a-z0-9]+)/   , line),
      out:      fm(/-i ([a-z0-9]+)/   , line),
      table:    fm(/-t (\w+)/         , line),
      states:   fm(/--state ([A-Z,]+)/ , line).split(','),
      to_dst:   fm(/--to-destination (\S+)/, line)
    };
  },

  /**
   * Simply returns the first regexp match in a string
   *
   * @param regexp {regexp} the regexp to scan for
   * @param string {string} the string to scan
   * @return {string} the first match
   */
  firstMatch: function(regexp, string) {
    return regexp.exec(string)[1];
  },

  /**
   * Renders a JS rule into the iptables rule arguments
   *
   * @param rule {object} the hash representing the rule args
   * @return {string} the string of iptables rule args
   */
  render: function(rule) {
    var args = [];

    // set some defaults
    if (!rule.chain)    rule.chain = 'INPUT';
    if (!rule.protocol) rule.protocol = 'tcp';

    // build the args up
    if (rule.table)     args = args.contact(['-t',            , rule.table]);
    if (rule.chain)     args = args.concat([rule.action       , rule.chain]);
    if (rule.protocol)  args = args.concat(["-p"              , rule.protocol]);
    if (rule.src)       args = args.concat(["--src"           , rule.src]);
    if (rule.dst)       args = args.concat(["--dst"           , rule.dst]);
    if (rule.sport)     args = args.concat(["--sport"         , rule.sport]);
    if (rule.dport)     args = args.concat(["--dport"         , rule.dport]);
    if (rule.in)        args = args.concat(["-i"              , rule.in]);
    if (rule.out)       args = args.concat(["-o"              , rule.out]);
    if (rule.target)    args = args.concat(["-j"              , rule.target]);
    if (rule.to_dst)    args = args.concat(["--to-destination", rule.to_dst]);
    if (rule.states)    args = args.concat(["-m state --state", rule.states.map(function(s) { return s.toUpperCase(); }).join(",")])

    return args.join(" ");
  }
};

module.exports = (function() {
  var home   = null,
      parser = RuleParser,
      db     = db;

  var init = function(_home) {
    home = _home;

  var buildIndex = function() {
    db.rules.forEach(function(rule, index) {
      db.index.by_name[rule.name] = index;
    });
  };

  /**
   * Returns the group by the given name
   *
   * @param name {string} name of the group
   * @return {object}
   */
  var get = function(id) {
    return db.getData('/groups/'+id);
  };

  /**
   * Returns an array of all groups from the db
   *
   * @return {array}
   */
  var all = function() {
    return db.getData('/groups');
  };

  /**
   * Find rules by name or glob pattern
   * 
   * @param pattern - the name or pattern to find
   * @callback rules - array of rules
   */
  var find = function(pattern, callback) {
    var rule;
    var wildcard = pattern.indexOf("*");

    if ( wildcard == -1 ) {
      if ( (rule = get(pattern)) != null) {
        callback(rule);
      } else {
        callback([]);
      }

      return;
    }

    var start    = (wildcard == 0) ? true : false,
        end      = (wildcard == pattern.length) ? true : false,
        pattern  = pattern.replace("*", ''),
        rules    = [];

console.log("iprules FIND: "+pattern+" : "+wildcard+" : "+start+" : "+end);

    // check if there was a wildcard specified
    if ( wildcard == -1 ) {
      if ( db.rules[name] !== undefined ) {
        callback([db.rules[name]]); // simply search for the name
      } else {
        callback([]); // nothing found
      }
    } else { // there was a wildcard
      Object.keys(db.rules).forEach(function(name) {

        if ( start ) {
          if (name.indexOf(pattern) == 0) rules.push(db.rules[name]);
        } else if ( end ) {
          var pos = name.length - pattern.length; // determine the start of the pattern
          if (name.indexOf(pattern) == pos ) rules.push(db.rules[name]);
        } else {
          // TODO: add pattern in the middle support
        }
        
      });
    }

console.log("iprules FOUND: "+rules.length);
console.log(rules);

    callback(rules);
  };

  /**
   * Imports rules from a file or directory and creates groups
   *
   * @param path {string}
   * @callback err
   * @callback groups {array} of successfully imported groups
   */
  var import = function(path, callback) {
    fs.exists(path, function(exists) {
      if ( !exists ) {
        callback(new Error("Path not found: "+path));
        return false;
      }

      // determine if the path given is a directory or file
      fs.stat(path, function(err, stats) {
        if ( stats.isFile() ) {
          importFile(path, function(err, group) {
            callback(err, [group]);
          });
        } else {
          importDirectory(path, callback);
        }
      });

    });
  };

  /**
   * Imports rules from a file and creates a group
   *
   * @param path {string} the path to the file
   * @callback err
   * @callback group {object} the imported group
   */ 
  var importFile = function(path, callback) {
    fs.readFile(path, function(err, text) {
      if (err) callback(err);
      text = text.replace(/^iptables /g, '');

      var group = {
        name: path,
        enabled: false,
        lines: text.split("\n");
      }

      create(group, callback);
    });
  };

  /**
   * Imports files from a directory
   *
   * @param path {string} the path name to import from
   * @callback err
   * @callback groups {array} of successfully imported groups
   */

  var importDirectory = function(path, callback) {
    fs.readdir(path, function(err, files) {
      if (err) callback && callback(err);
      var groups = [];
      
      files.forEach(function(file) {
        importFile(file, function(err, group) {
          if (!err) groups.push(group);
        });
      });

      if ( groups.length == 0 ) err = new Error("No rules imported from "+path);

      callback && callback(err, groups);
    });
  };

  /**
   * Saves the given group in the DB
   *
   * @param group {object}
   * @callback err
   * @callback group {object} the saved group with test data added
   */
  var create = function(group, callback) {
    if ( typeof group.enabled == undefined ) group.enabled = false;

    test([group], function(err, groups, failed) { // run tests and save results in the groups
      // create the group regardless of the test result
      var group = groups[0]
      
      if ( group.id == undefined ) {
        group.id = db.getData('/groups').length;
      }

      db.push('/groups/'+group.id, group);

      callback(err, group);
    });
  };

  /**
   * Updates the given group in the database
   *
   * @param group {object} the group to update
   * @callback err
   * @callback group {object} the group after being tested and saved
   */
  var update = function(group, callback) {
    test([group], function(err, groups, failed) {
      if ( err ) callback && callback(err);
      db.push('/groups/'+groups[0].id, groups[0]);
      callback && callback(err, group[0]);
    });
  };

  /**
   * Destroys the rule with the given ID
   *
   * @param id {integer}
   */
  var destroy = function(id) {
    db.delete('/groups/'+id);
  };

  /**
   * Tests the given groups by using the iptables-restore command
   *
   * @param groups {array} the groups of rule groups to test
   * @callback err
   * @callback groups {array} the groups with test data added
   * @callback failed {integer} the total number of test failures
   */
  var test = function(groups, callback) {
    var failed  = 0;

    // run the test against each group and save it's results to 
    groups = groups.map(function(group) {
      testGroup(group, function(err, test_lines) {
        group.valid      = err == null;
        group.test_lines = test_lines;
        if ( err ) {
          failed++;
          group.error = err.message;
          if ( group.enabled ) group.enabled = false; // disable the group so it doesn't run
        } else {
          group.error = false;
        }
      });

      return group;
    });

    callback(null, groups, failed);
  };

  /**
   * Tests a group of rules
   * @param group {object}
   * @callback err
   * @callback lines {array} lines of the file that was tested
   */
  var testGroup = function(group, callback) {
    IptablesRestore.test(compile([group]), function(err, text) {
      callback(err, text.split("\n"));
    });
  };
  
  var enable = function(name) {
    var group = db.getData(name);
    group.enabled = true;
    db.push('/groups/'+name, group);
  };

  var disable = function(name, callback) {
    var group = db.getData(name);
    group.enabled = false;
    db.push('/groups/'+name, group);
  };

  /*
   * Compiles given groups into an iptables-rules file
   * represented as an array of lines
   * 
   * @param groups
   * @return lines {array}
   */
  var compile = function(groups, join) {
    var lines = [];

    groups.forEach(function(group) {
      lines.push("# "+group.name);
      
      group.lines.forEach(function(line) {
        if ( typeof(line) == "string" ) {
          lines.push(line);
        } else if ( typeof(line) == "object" ) {
          line = RuleParser.render(line);
          lines.push(line);
        }
      });

      lines.push("");      
    });

    return (join === false) lines : lines.join("\n"); // join by default
  };

  /**
   * Reload enabled groups into IP Tables
   *
   * @callback err
   */
  var reload = function(callback) {
    var groups = [];

    db.getData("/groups").forEach(function(group) {
      if ( group.enabled && group.valid ) groups.push(group);
    });


    IptablesRestore.load(compile(groups), function(err) {
      callback && callback(err, lines);
    });
  };

  return {
    init: init,
    parser: parser,
    all: all,
    importRules: importRules,
    enable: enable,
    disable: disable,
    create: create,
    update: update,
    test: test,
    reload: reload,
    find: find,
    destroy: destroy
  }
}());